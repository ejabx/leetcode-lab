notebooks:
  - metadata:
      title: "Best Time to Buy and Sell Stock"
      filename: "121-best-time-to-buy-and-sell-stock.ipynb"
    cells:
      - type: markdown
        content: |
          # [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock)
          ## Description  
          Determine the maximum profit you can achieve from a single buy and a single sell, given a list of stock prices over time.
          ## Strategy  
          Use a single-pass approach to track the minimum price so far and update the max profit as you go.
      - type: code
        content: |
          export function maxProfit(prices: number[]): number {
            return 0;
          }
      - type: code
        content: |
          import { assertEquals } from "https://deno.land/std/testing/asserts.ts";
          import { maxProfit } from "./121-best-time-to-buy-and-sell-stock.ts";

          Deno.test("maxProfit basic", () => {
            assertEquals(maxProfit([7,1,5,3,6,4]), 5);
          });

          Deno.test("maxProfit no profit", () => {
            assertEquals(maxProfit([7,6,4,3,1]), 0);
          });

          Deno.test("maxProfit single day", () => {
            assertEquals(maxProfit([5]), 0);
          });

          Deno.test("maxProfit empty", () => {
            assertEquals(maxProfit([]), 0);
          })
  - metadata:
      title: "Implement Trie (Prefix Tree)"
      filename: "208-implement-trie-prefix-tree.ipynb"
    cells:
      - type: markdown
        content: |
          # [Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree)
          ## Description  
          Design a Trie data structure to insert words, search for exact matches, and check prefixes.
          ## Strategy  
          Use nested hash maps (objects) or a class-based tree structure to represent nodes with character keys.
      - type: code
        content: |
          export class Trie {
            constructor() {}

            insert(word: string): void {}

            search(word: string): boolean {
              return false;
            }

            startsWith(prefix: string): boolean {
              return false;
            }
          }
      - type: code
        content: |
          import { assertEquals } from "https://deno.land/std/testing/asserts.ts";

          Deno.test("Trie basic operations", () => {
            const trie = new Trie();
            trie.insert("apple");
            assertEquals(trie.search("apple"), true);
            assertEquals(trie.search("app"), false);
            assertEquals(trie.startsWith("app"), true);
            trie.insert("app");
            assertEquals(trie.search("app"), true);
          });
  - metadata:
      title: "Word Search II"
      filename: "212-word-search-ii.ipynb"
    cells:
      - type: markdown
        content: |
          # [Word Search II](https://leetcode.com/problems/word-search-ii)
          ## Description  
          Given a board and a list of words, find all the words present in the board using DFS with prefix pruning.
          ## Strategy  
          Use a Trie for efficient prefix checks and backtrack through the board to find valid words.
      - type: code
        content: |
          export function findWords(board: string[][], words: string[]): string[] {
            return [];
          }
      - type: code
        content: |
          import { assertEquals } from "https://deno.land/std/testing/asserts.ts";
          import { findWords } from "./212-word-search-ii.ts";

          Deno.test("findWords basic", () => {
            const board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]];
            const words = ["oath","pea","eat","rain"];
            assertEquals(findWords(board, words).sort(), ["eat","oath"].sort());
          });

          Deno.test("findWords edge", () => {
            assertEquals(findWords([], ["abc"]), []);
            assertEquals(findWords([["a"]], ["a"]), ["a"]);
          });
  - metadata:
      title: "Serialize and Deserialize Binary Tree"
      filename: "297-serialize-and-deserialize-binary-tree.ipynb"
    cells:
      - type: markdown
        content: |
          # [Serialize and Deserialize Binary Tree](https://leetcode.com/problems/serialize-and-deserialize-binary-tree)
          ## Description  
          Convert a binary tree to a string and back using a serialization format.
          ## Strategy  
          Use preorder traversal with "null" markers for missing nodes to maintain structure.
      - type: code
        content: |
          import { TreeNode } from "../bin/utils.ts"

          export class Codec {
            serialize(root: TreeNode | null): string {
              return "";
            }

            deserialize(data: string): TreeNode | null {
              return null;
            }
          }
      - type: code
        content: |
          import { assert } from "https://deno.land/std/testing/asserts.ts";

          Deno.test("serialize and deserialize basic", () => {
            const codec = new Codec();
            const tree = new TreeNode(1, new TreeNode(2), new TreeNode(3));
            const data = codec.serialize(tree);
            const restored = codec.deserialize(data);
            assert(codec.serialize(restored) === data);
          });
  - metadata:
      title: "Alien Dictionary"
      filename: "269-alien-dictionary.ipynb"
    cells:
      - type: markdown
        content: |
          # [Alien Dictionary](https://leetcode.com/problems/alien-dictionary)
          ## Description  
          Given a sorted list of words from an alien language, derive the order of the alphabet.
          ## Strategy  
          Build a graph based on pairwise character precedence and use topological sort.
      - type: code
        content: |
          export function alienOrder(words: string[]): string {
            return "";
          }
      - type: code
        content: |
          import { assertEquals } from "https://deno.land/std/testing/asserts.ts";

          Deno.test("alienOrder basic", () => {
            assertEquals(alienOrder(["wrt","wrf","er","ett","rftt"]), "wertf");
          });

          Deno.test("alienOrder invalid", () => {
            assertEquals(alienOrder(["z","x","z"]), "");
          });
  - metadata:
      title: "Design Twitter"
      filename: "355-design-twitter.ipynb"
    cells:
      - type: markdown
        content: |
          # [Design Twitter](https://leetcode.com/problems/design-twitter)
          ## Description  
          Design a simplified version of Twitter to post tweets, follow users, and retrieve timelines.
          ## Strategy  
          Maintain tweet history and follower relationships using maps and priority queues.
      - type: code
        content: |
          export class Twitter {
            constructor() {}

            postTweet(userId: number, tweetId: number): void {}

            getNewsFeed(userId: number): number[] {
              return [];
            }

            follow(followerId: number, followeeId: number): void {}

            unfollow(followerId: number, followeeId: number): void {}
          }
      - type: code
        content: |
          import { assertEquals } from "https://deno.land/std/testing/asserts.ts";

          Deno.test("Twitter basic usage", () => {
            const twitter = new Twitter();
            twitter.postTweet(1, 5);
            assertEquals(twitter.getNewsFeed(1), [5]);
            twitter.follow(1, 2);
            twitter.postTweet(2, 6);
            assertEquals(twitter.getNewsFeed(1), [6, 5]);
            twitter.unfollow(1, 2);
            assertEquals(twitter.getNewsFeed(1), [5]);
          });
  - metadata:
      title: "Number of Islands II"
      filename: "305-number-of-islands-ii.ipynb"
    cells:
      - type: markdown
        content: |
          # Number of Islands II  
          [LeetCode Link](https://leetcode.com/problems/number-of-islands-ii)

      - type: markdown
        content: |
          ## Description  
          Track the number of islands as land is added incrementally to a 2D water grid.

      - type: markdown
        content: |
          ## Strategy  
          Use Union-Find (Disjoint Set Union) to dynamically merge connected components as new land is added.

      - type: code
        content: |
          export function numIslands2(m: number, n: number, positions: number[][]): number[] {
            return [];
          }

      - type: code
        content: |
          import { assertEquals } from "https://deno.land/std/testing/asserts.ts";

          Deno.test("numIslands2 - basic", () => {
            assertEquals(numIslands2(3, 3, [[0,0],[0,1],[1,2],[2,1]]), [1,1,2,3]);
          });

          Deno.test("numIslands2 - single addition", () => {
            assertEquals(numIslands2(1, 1, [[0,0]]), [1]);
          });

          Deno.test("numIslands2 - duplicate positions", () => {
            assertEquals(numIslands2(2, 2, [[0,0],[0,0],[1,1]]), [1,1,2]);
          });

          Deno.test("numIslands2 - no positions", () => {
            assertEquals(numIslands2(2, 2, []), []);
          });
  - metadata:
      title: "Word Ladder"
      filename: "127-word-ladder.ipynb"
    cells:
      - type: markdown
        content: |
          # Word Ladder  
          [LeetCode Link](https://leetcode.com/problems/word-ladder)

      - type: markdown
        content: |
          ## Description  
          Find the shortest transformation sequence from `beginWord` to `endWord`, changing one letter at a time using words in a given list.

      - type: markdown
        content: |
          ## Strategy  
          Use BFS to find the shortest path between the start and end words through valid transformations.

      - type: code
        content: |
          export function ladderLength(beginWord: string, endWord: string, wordList: string[]): number {
            return 0;
          }

      - type: code
        content: |
          import { assertEquals } from "https://deno.land/std/testing/asserts.ts";

          Deno.test("ladderLength - basic", () => {
            assertEquals(ladderLength("hit", "cog", ["hot","dot","dog","lot","log","cog"]), 5);
          });

          Deno.test("ladderLength - unreachable end", () => {
            assertEquals(ladderLength("hit", "cog", ["hot","dot","dog","lot","log"]), 0);
          });

          Deno.test("ladderLength - single word", () => {
            assertEquals(ladderLength("hit", "hit", ["hit"]), 1);
          });

          Deno.test("ladderLength - empty wordList", () => {
            assertEquals(ladderLength("hit", "cog", []), 0);
          });
  - metadata:
      title: "Cheapest Flights Within K Stops"
      filename: "787-cheapest-flights-within-k-stops.ipynb"
    cells:
      - type: markdown
        content: |
          # Cheapest Flights Within K Stops  
          [LeetCode Link](https://leetcode.com/problems/cheapest-flights-within-k-stops)

      - type: markdown
        content: |
          ## Description  
          Find the cheapest price from a source to destination within at most K stops using flight data.

      - type: markdown
        content: |
          ## Strategy  
          Use a modified Dijkstra's or BFS algorithm tracking stops as an extra constraint.

      - type: code
        content: |
          export function findCheapestPrice(n: number, flights: number[][], src: number, dst: number, k: number): number {
            return -1;
          }

      - type: code
        content: |
          import { assertEquals } from "https://deno.land/std/testing/asserts.ts";

          Deno.test("findCheapestPrice - basic", () => {
            assertEquals(findCheapestPrice(3, [[0,1,100],[1,2,100],[0,2,500]], 0, 2, 1), 200);
          });

          Deno.test("findCheapestPrice - direct cheaper", () => {
            assertEquals(findCheapestPrice(3, [[0,1,100],[1,2,100],[0,2,50]], 0, 2, 1), 50);
          });

          Deno.test("findCheapestPrice - no valid path", () => {
            assertEquals(findCheapestPrice(3, [[0,1,100],[1,2,100]], 0, 2, 0), -1);
          });

          Deno.test("findCheapestPrice - empty flights", () => {
            assertEquals(findCheapestPrice(3, [], 0, 2, 1), -1);
          });

          Deno.test("findCheapestPrice - long route cheaper", () => {
            assertEquals(findCheapestPrice(4, [[0,1,100],[1,2,100],[2,3,100],[0,3,500]], 0, 3, 2), 300);
          });
  - metadata:
      title: "Word Break II"
      filename: "140-word-break-ii.ipynb"
    cells:
      - type: markdown
        content: |
          # Word Break II  
          [LeetCode Link](https://leetcode.com/problems/word-break-ii)

      - type: markdown
        content: |
          ## Description  
          Return all possible sentences by segmenting a string into valid dictionary words.

      - type: markdown
        content: |
          ## Strategy  
          Use DFS with memoization to explore all possible word breaks.

      - type: code
        content: |
          export function wordBreak(s: string, wordDict: string[]): string[] {
            return [];
          }

      - type: code
        content: |
          import { assertEquals } from "https://deno.land/std/testing/asserts.ts";

          Deno.test("wordBreak - multiple combinations", () => {
            assertEquals(
              wordBreak("catsanddog", ["cat","cats","and","sand","dog"]).sort(),
              ["cat sand dog","cats and dog"].sort()
            );
          });

          Deno.test("wordBreak - single match", () => {
            assertEquals(wordBreak("apple", ["apple"]), ["apple"]);
          });

          Deno.test("wordBreak - no match", () => {
            assertEquals(wordBreak("abcd", ["a","abc","b","cd"]), []);
          });

          Deno.test("wordBreak - empty input", () => {
            assertEquals(wordBreak("", ["a"]), []);
          });

          Deno.test("wordBreak - overlapping options", () => {
            assertEquals(
              wordBreak("pineapplepenapple", ["apple","pen","applepen","pine","pineapple"]).sort(),
              [
                "pine apple pen apple",
                "pineapple pen apple",
                "pine applepen apple"
              ].sort()
            );
          });
  - metadata:
      title: "Meeting Rooms II"
      filename: "253-meeting-rooms-ii.ipynb"
    cells:
      - type: markdown
        content: |
          # Meeting Rooms II  
          [LeetCode Link](https://leetcode.com/problems/meeting-rooms-ii)

      - type: markdown
        content: |
          ## Description  
          Return the minimum number of meeting rooms required given an array of meeting time intervals.

      - type: markdown
        content: |
          ## Strategy  
          Use a min-heap to keep track of ongoing meetings and manage room allocation efficiently.

      - type: code
        content: |
          export function minMeetingRooms(intervals: number[][]): number {
            return 0;
          }

      - type: code
        content: |
          import { assertEquals } from "https://deno.land/std/testing/asserts.ts";

          Deno.test("minMeetingRooms - basic", () => {
            assertEquals(minMeetingRooms([[0,30],[5,10],[15,20]]), 2);
          });

          Deno.test("minMeetingRooms - non-overlapping", () => {
            assertEquals(minMeetingRooms([[7,10],[2,4]]), 1);
          });

          Deno.test("minMeetingRooms - all at same time", () => {
            assertEquals(minMeetingRooms([[1,5],[1,5],[1,5]]), 3);
          });

          Deno.test("minMeetingRooms - empty input", () => {
            assertEquals(minMeetingRooms([]), 0);
          });

  - metadata:
      title: "Task Scheduler"
      filename: "621-task-scheduler.ipynb"
    cells:
      - type: markdown
        content: |
          # Task Scheduler  
          [LeetCode Link](https://leetcode.com/problems/task-scheduler)

      - type: markdown
        content: |
          ## Description  
          Find the least number of units of time needed to finish all tasks given a cooldown interval.

      - type: markdown
        content: |
          ## Strategy  
          Use greedy counting of most frequent tasks and fill gaps accordingly.

      - type: code
        content: |
          export function leastInterval(tasks: string[], n: number): number {
            return 0;
          }

      - type: code
        content: |
          import { assertEquals } from "https://deno.land/std/testing/asserts.ts";

          Deno.test("leastInterval - basic", () => {
            assertEquals(leastInterval(["A","A","A","B","B","B"], 2), 8);
          });

          Deno.test("leastInterval - no cooldown", () => {
            assertEquals(leastInterval(["A","A","A","B","B","B"], 0), 6);
          });

          Deno.test("leastInterval - one task", () => {
            assertEquals(leastInterval(["A"], 2), 1);
          });

          Deno.test("leastInterval - all unique", () => {
            assertEquals(leastInterval(["A","B","C"], 2), 3);
          });

  - metadata:
      title: "Longest Valid Parentheses"
      filename: "32-longest-valid-parentheses.ipynb"
    cells:
      - type: markdown
        content: |
          # Longest Valid Parentheses  
          [LeetCode Link](https://leetcode.com/problems/longest-valid-parentheses)

      - type: markdown
        content: |
          ## Description  
          Find the length of the longest valid (well-formed) parentheses substring.

      - type: markdown
        content: |
          ## Strategy  
          Use a stack to track open parentheses or use dynamic programming for efficiency.

      - type: code
        content: |
          export function longestValidParentheses(s: string): number {
            return 0;
          }

      - type: code
        content: |
          import { assertEquals } from "https://deno.land/std/testing/asserts.ts";

          Deno.test("longestValidParentheses - nested", () => {
            assertEquals(longestValidParentheses("(()"), 2);
          });

          Deno.test("longestValidParentheses - complex", () => {
            assertEquals(longestValidParentheses(")()())"), 4);
          });

          Deno.test("longestValidParentheses - empty", () => {
            assertEquals(longestValidParentheses(""), 0);
          });

          Deno.test("longestValidParentheses - all open", () => {
            assertEquals(longestValidParentheses("(((("), 0);
          });

  - metadata:
      title: "Burst Balloons"
      filename: "312-burst-balloons.ipynb"
    cells:
      - type: markdown
        content: |
          # Burst Balloons  
          [LeetCode Link](https://leetcode.com/problems/burst-balloons)

      - type: markdown
        content: |
          ## Description  
          You are given n balloons. Each balloon has a number. You burst them in some order. When you burst a balloon `i`, you gain `nums[left] * nums[i] * nums[right]` coins.

      - type: markdown
        content: |
          ## Strategy  
          Use DP to try every possible bursting order and memorize overlapping subproblems.

      - type: code
        content: |
          export function maxCoins(nums: number[]): number {
            return 0;
          }

      - type: code
        content: |
          import { assertEquals } from "https://deno.land/std/testing/asserts.ts";

          Deno.test("maxCoins - basic", () => {
            assertEquals(maxCoins([3,1,5,8]), 167);
          });

          Deno.test("maxCoins - single balloon", () => {
            assertEquals(maxCoins([1]), 1);
          });

          Deno.test("maxCoins - empty input", () => {
            assertEquals(maxCoins([]), 0);
          });

          Deno.test("maxCoins - two balloons", () => {
            assertEquals(maxCoins([1,5]), 10);
          });
  - metadata:
      title: "Course Schedule"
      filename: "207-course-schedule.ipynb"
    cells:
      - type: markdown
        content: |
          # Course Schedule  
          [LeetCode Link](https://leetcode.com/problems/course-schedule)

      - type: markdown
        content: |
          ## Description  
          Determine if it's possible to finish all courses given their prerequisites.

      - type: markdown
        content: |
          ## Strategy  
          Use topological sorting (BFS with in-degree or DFS with cycle detection) to detect if a cycle exists in the dependency graph.

      - type: code
        content: |
          export function canFinish(numCourses: number, prerequisites: number[][]): boolean {
            return false;
          }

      - type: code
        content: |
          import { assertEquals } from "https://deno.land/std/testing/asserts.ts";

          Deno.test("canFinish - no prerequisites", () => {
            assertEquals(canFinish(2, []), true);
          });

          Deno.test("canFinish - simple cycle", () => {
            assertEquals(canFinish(2, [[1, 0], [0, 1]]), false);
          });

          Deno.test("canFinish - acyclic graph", () => {
            assertEquals(canFinish(4, [[1, 0], [2, 1], [3, 2]]), true);
          });

          Deno.test("canFinish - complex cycle", () => {
            assertEquals(canFinish(3, [[0,1],[1,2],[2,0]]), false);
          });

          Deno.test("canFinish - disconnected components", () => {
            assertEquals(canFinish(5, [[1,0],[3,4]]), true);
          });
  - metadata:
      title: "Clone Graph"
      filename: "133-clone-graph.ipynb"
    cells:
      - type: markdown
        content: |
          # Clone Graph  
          [LeetCode Link](https://leetcode.com/problems/clone-graph)

      - type: markdown
        content: |
          ## Description  
          Return a deep copy (clone) of an undirected graph, given a reference to one of its nodes.

      - type: markdown
        content: |
          ## Strategy  
          Use DFS or BFS with a map to keep track of visited nodes and their clones to avoid infinite loops and preserve graph structure.

      - type: code
        content: |
          export class Node {
            val: number;
            neighbors: Node[];

            constructor(val?: number, neighbors?: Node[]) {
              this.val = val ?? 0;
              this.neighbors = neighbors ?? [];
            }
          }

          export function cloneGraph(node: Node | null): Node | null {
            return null;
          }

      - type: code
        content: |
          import { assertEquals } from "https://deno.land/std/testing/asserts.ts";

          function serialize(node: Node | null): any {
            if (!node) return null;
            const seen = new Map<Node, number>();
            const result: Record<number, number[]> = {};
            let id = 1;

            const dfs = (n: Node) => {
              if (seen.has(n)) return;
              seen.set(n, n.val);
              result[n.val] = n.neighbors.map(nei => nei.val);
              for (const nei of n.neighbors) {
                dfs(nei);
              }
            };

            dfs(node);
            return result;
          }

          Deno.test("cloneGraph - null input", () => {
            assertEquals(cloneGraph(null), null);
          });

          Deno.test("cloneGraph - single node", () => {
            const node = new Node(1);
            const clone = cloneGraph(node);
            assertEquals(serialize(clone), { 1: [] });
          });

          Deno.test("cloneGraph - two connected nodes", () => {
            const node1 = new Node(1);
            const node2 = new Node(2);
            node1.neighbors.push(node2);
            node2.neighbors.push(node1);

            const clone = cloneGraph(node1);
            assertEquals(serialize(clone), { 1: [2], 2: [1] });
          });

          Deno.test("cloneGraph - triangle graph", () => {
            const node1 = new Node(1);
            const node2 = new Node(2);
            const node3 = new Node(3);
            node1.neighbors = [node2, node3];
            node2.neighbors = [node1, node3];
            node3.neighbors = [node1, node2];

            const clone = cloneGraph(node1);
            assertEquals(serialize(clone), {
              1: [2, 3],
              2: [1, 3],
              3: [1, 2],
            });
          });
